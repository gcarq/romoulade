pub mod constants;

use crate::gb::memory::constants::*;
use crate::gb::AddressSpace;
use crate::utils;

pub struct MemoryBus {
    boot: [u8; BOOT_SIZE],
    vram: [u8; VRAM_SIZE],
    cram: [u8; CRAM_SIZE],
    wram: [u8; WRAM_SIZE],
    eram: [u8; ERAM_SIZE],
    rom: Vec<u8>, // [u8; 0xFFFF]
    oam: [u8; OAM_SIZE],
    io: [u8; IO_SIZE],
    hram: [u8; HRAM_SIZE],
    ie: u8,
}

impl MemoryBus {
    pub fn new(rom: Vec<u8>) -> Self {
        let boot = [
            0x31, 0xFE, 0xFF, 0xAF, 0x21, 0xFF, 0x9F, 0x32, 0xCB, 0x7C, 0x20, 0xFB, 0x21, 0x26,
            0xFF, 0x0E, 0x11, 0x3E, 0x80, 0x32, 0xE2, 0x0C, 0x3E, 0xF3, 0xE2, 0x32, 0x3E, 0x77,
            0x77, 0x3E, 0xFC, 0xE0, 0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1A, 0xCD, 0x95,
            0x00, 0xCD, 0x96, 0x00, 0x13, 0x7B, 0xFE, 0x34, 0x20, 0xF3, 0x11, 0xD8, 0x00, 0x06,
            0x08, 0x1A, 0x13, 0x22, 0x23, 0x05, 0x20, 0xF9, 0x3E, 0x19, 0xEA, 0x10, 0x99, 0x21,
            0x2F, 0x99, 0x0E, 0x0C, 0x3D, 0x28, 0x08, 0x32, 0x0D, 0x20, 0xF9, 0x2E, 0x0F, 0x18,
            0xF3, 0x67, 0x3E, 0x64, 0x57, 0xE0, 0x42, 0x3E, 0x91, 0xE0, 0x40, 0x04, 0x1E, 0x02,
            0x0E, 0x0C, 0xF0, 0x44, 0xFE, 0x90, 0x20, 0xFA, 0x0D, 0x20, 0xF7, 0x1D, 0x20, 0xF2,
            0x0E, 0x13, 0x24, 0x7C, 0x1E, 0x83, 0xFE, 0x62, 0x28, 0x06, 0x1E, 0xC1, 0xFE, 0x64,
            0x20, 0x06, 0x7B, 0xE2, 0x0C, 0x3E, 0x87, 0xE2, 0xF0, 0x42, 0x90, 0xE0, 0x42, 0x15,
            0x20, 0xD2, 0x05, 0x20, 0x4F, 0x16, 0x20, 0x18, 0xCB, 0x4F, 0x06, 0x04, 0xC5, 0xCB,
            0x11, 0x17, 0xC1, 0xCB, 0x11, 0x17, 0x05, 0x20, 0xF5, 0x22, 0x23, 0x22, 0x23, 0xC9,
            0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C,
            0x00, 0x0D, 0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6,
            0xDD, 0xDD, 0xD9, 0x99, 0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC,
            0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E, 0x3C, 0x42, 0xB9, 0xA5, 0xB9, 0xA5, 0x42, 0x3C,
            0x21, 0x04, 0x01, 0x11, 0xA8, 0x00, 0x1A, 0x13, 0xBE, 0x00, 0x00, 0x23, 0x7D, 0xFE,
            0x34, 0x20, 0xF5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xFB, 0x86, 0x00, 0x00,
            0x3E, 0x01, 0xE0, 0x50,
        ];

        Self {
            boot,
            rom,
            vram: [0u8; VRAM_SIZE],
            cram: [0u8; CRAM_SIZE],
            wram: [0u8; WRAM_SIZE],
            eram: [0u8; ERAM_SIZE],
            oam: [0u8; OAM_SIZE],
            io: [0u8; IO_SIZE],
            hram: [0u8; HRAM_SIZE],
            ie: 0,
        }
    }

    // Requests an interrupt for the given id
    // TODO: create enum? See interrupt.rs
    pub fn irq(&mut self, id: u8) {
        let req = utils::set_bit(self.read(INTERRUPT_FLAG), id, true);
        self.write(INTERRUPT_FLAG, req);
    }
}

impl AddressSpace for MemoryBus {
    fn write(&mut self, address: u16, value: u8) {
        // TODO: Implement DMA Transfer if address == 0xFF46
        //println!("MMU: writing: {:#06x}: {:#04x}", address, value);
        match address {
            BOOT_BEGIN..=BOOT_END => panic!("Trying to write byte to Boot ROM: {:#06x}", address),
            0x0100..=0x7FFF => panic!("Trying to write byte to Cartridge ROM: {:#06x}", address),
            VRAM_BEGIN..=VRAM_END => self.vram[(address - VRAM_BEGIN) as usize] = value,
            CRAM_BEGIN..=CRAM_END => self.cram[(address - CRAM_BEGIN) as usize] = value,
            WRAM_BEGIN..=WRAM_END => self.wram[(address - WRAM_BEGIN) as usize] = value,
            ERAM_BEGIN..=ERAM_END => {
                // Mirrors Working RAM
                self.eram[(address - ERAM_BEGIN) as usize] = value;
                self.wram[(address - WRAM_BEGIN) as usize] = value;
            }
            OAM_BEGIN..=OAM_END => self.oam[(address - OAM_BEGIN) as usize] = value,
            0xFEA0..=0xFEFF => {} // This area is unmapped, writing to it does nothing.
            IO_BEGIN..=IO_END => self.io[(address - IO_BEGIN) as usize] = value,
            HRAM_BEGIN..=HRAM_END => self.hram[(address - HRAM_BEGIN) as usize] = value,
            INTERRUPT_ENABLE => self.ie = value,
        }
    }

    fn read(&self, address: u16) -> u8 {
        match address {
            BOOT_BEGIN..=BOOT_END => self.boot[(address - BOOT_BEGIN) as usize],
            0x0100..=0x7FFF => self.rom[address as usize], // TODO: unload boot rom and replace it with rom
            VRAM_BEGIN..=VRAM_END => self.vram[(address - VRAM_BEGIN) as usize],
            CRAM_BEGIN..=CRAM_END => self.cram[(address - CRAM_BEGIN) as usize],
            WRAM_BEGIN..=WRAM_END => self.wram[(address - WRAM_BEGIN) as usize],
            ERAM_BEGIN..=ERAM_END => self.eram[(address - ERAM_BEGIN) as usize],
            OAM_BEGIN..=OAM_END => self.oam[(address - OAM_BEGIN) as usize],
            0xFEA0..=0xFEFF => 0, // This area is unmapped, reading from it should return 0.
            IO_BEGIN..=IO_END => self.io[(address - IO_BEGIN) as usize],
            HRAM_BEGIN..=HRAM_END => self.hram[(address - HRAM_BEGIN) as usize],
            INTERRUPT_ENABLE => self.ie,
        }
    }
}
